<?php

namespace app\modules\hr\models\embedded;


use MongoDB\BSON\ObjectID;

use app\modules\hr\Module;

use app\modules\hr\models\Order;
use app\modules\hr\models\DictionaryWord;
use app\modules\hr\validators\DictionaryWordValidator;
use app\modules\hr\traits\DictionaryWordEmbedded;


/**
 * Class Hiring
 *
 * @property integer $probation_months Испытательный срок (в месяцах)
 * @property integer $employment Условия приема на работу
 * @property ObjectID $__employment_term Характер работы / Условия приема на работу (на какой условный срок принимают на работу)
 * @property string $date_begin Дата начала работы (строка)
 * @property integer $date_begin_unixtime Дата начала работы (UNIX-время)
 * @property string $date_end Дата окончания работы (строка)
 * @property integer $date_end_unixtime Дата окончания работы (UNIX-время)
 *
 * @package app\modules\hr\models\embedded
 */
class Hiring extends EmbeddedModel
{
    use DictionaryWordEmbedded;

    const DATE_REGEXP_PATTERN = '/^[0-9]{1,2}\.[0-9]{1,2}\.[0-9]{4}$/i';
    const DATE_REGEXP_PATTERN_LABEL = 'дд.мм.гггг';
    const DATE_REGEXP_PATTERN_FOR_DATE_PICKER = 'dd.mm.yyyy';
    const DATE_PHP_FORMAT = 'd.m.Y';

    /** Условие приема на работу: полный рабочий день (полная занятость) */
    const EMPLOYMENT__FILL_TIME = 100;
    /** Условие приема на работу: неполная занятость */
    const EMPLOYMENT__PART_TIME = 200;
    //const EMPLOYMENT_TEMPORARY = 300;
    //const EMPLOYMENT_FLEXTIME = 400;

    /** @var integer */
    public $probation_months;
    /** @var integer */
    public $employment;
    /** @var ObjectID */
    public $__employment_term;
    /** @var string */
    public $date_begin;
    /** @var integer */
    public $date_begin_unixtime;
    /** @var string */
    public $date_end;
    /** @var integer */
    public $date_end_unixtime;

    public function scenarios()
    {
        return [
            self::SCENARIO_DEFAULT => [
                'probation_months',
                'employment',
                '__employment_term',
                'date_begin',
                'date_end',
            ],
        ];
    }

    /**
     * @return array
     */
    public function rules()
    {
        return [
            ['probation_months', 'integer'],

            ['employment', 'filter', 'filter' => 'intval'],
            ['employment', 'in', 'range' => array_keys(self::employmentLabels())],

            [['date_begin', 'date_end'], 'match',
                'pattern' => self::DATE_REGEXP_PATTERN,
                'message' => Module::t('hiring', 'DATE__VALIDATE_MESSAGE__BAD_DATE', [
                    'format' => self::DATE_REGEXP_PATTERN_LABEL,
                ]),
            ],

            ['__employment_term', DictionaryWordValidator::className(), 'dictionary' => DictionaryWord::DICTIONARY_EMPLOYMENT_TERM],

            [['employment', 'date_begin', '__employment_term'], 'required'],
        ];
    }

    /**
     * @return array
     */
    public function attributeLabels()
    {
        return [
            'probation_months'  => Module::t('hiring', 'ATTR__PROBATION_MONTHS__LABEL'),
            'employment'        => Module::t('hiring', 'ATTR__EMPLOYMENT__LABEL'),
            '__employment_term' => Module::t('hiring', 'ATTR__EMPLOYMENT_TERM__LABEL'),
            'date_begin'        => Module::t('hiring', 'ATTR__DATE_BEGIN__LABEL'),
            'date_end'          => Module::t('hiring', 'ATTR__DATE_END__LABEL'),
        ];
    }

    public function afterValidate()
    {
        $this->date_begin_unixtime = ($date_begin_unixtime = strtotime($this->date_begin) !== false) ? $date_begin_unixtime : null;
        $this->date_end_unixtime = ($date_end_unixtime = strtotime($this->date_end) !== false) ? $date_end_unixtime : null;
        parent::afterValidate(); // TODO: Change the autogenerated stub
    }

    /**
     * Условия приема на работу (на какой условный срок принимают на работу)
     * @return string|null
     */
    public function getEmploymentTerm()
    {
        if ($model = $this->getDictionaryWordModelByAttribute('__employment_term')) {
            return $model->getWord();
        }
        return null;
    }

    /**
     * Типы занятостей (в понятном человеку формате)<br/>
     * @return array Key(type) => Value (label)
     */
    public static function employmentLabels()
    {
        return [
            self::EMPLOYMENT__FILL_TIME => Module::t('hiring', 'EMPLOYMENT__FILL_TIME__LABEL'),
            self::EMPLOYMENT__PART_TIME => Module::t('hiring', 'EMPLOYMENT__PART_TIME__LABEL'),
        ];
    }

    /**
     * Тип занятости (в понятном человеку формате)
     * @return mixed|string
     */
    public function getEmploymentLabel()
    {
        $list = self::employmentLabels();
        if (isset($list[$this->employment])) {
            return $list[$this->employment];
        }
        return Module::t('hiring', 'EMPLOYMENT__UNKNOWN');
    }

    protected static function labelForExportColumn($message)
    {
        return Module::t('hiring', 'MODEL_NAME') . ': ' . Module::t('hiring', $message);
    }

    public static function exportColumnsConfig($attribute)
    {
        return [
            [
                'attribute' => $attribute . '.probation_months',
                'label' => self::labelForExportColumn('ATTR__PROBATION_MONTHS__LABEL'),
            ],
            [
                'attribute' => $attribute . '.employment',
                'label' => self::labelForExportColumn('ATTR__EMPLOYMENT__LABEL'),
                'value' => function($model) {
                    /** @var Order $model */
                    return $model->hiring->getEmploymentLabel();
                }
            ],
            [
                'attribute' => $attribute . '.__employment_term',
                'label' => self::labelForExportColumn('ATTR__EMPLOYMENT_TERM__LABEL'),
                'value' => function($model) {
                    /** @var Order $model */
                    return $model->hiring->getEmploymentTerm();
                }
            ],
            [
                'attribute' => $attribute . '.date_begin',
                'label' => self::labelForExportColumn('ATTR__DATE_BEGIN__LABEL'),
            ],
            [
                'attribute' => $attribute . '.date_end',
                'label' => self::labelForExportColumn('ATTR__DATE_END__LABEL'),
            ],
        ];
    }
}